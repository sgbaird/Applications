(* ::Package:: *)

(************************************************************************)
(* This file was generated automatically by the Mathematica front end.  *)
(* It contains Initialization cells from a Notebook file, which         *)
(* typically will have the same name as this file except ending in      *)
(* ".nb" instead of ".m".                                               *)
(*                                                                      *)
(* This file is intended to be loaded into the Mathematica kernel using *)
(* the package loading commands Get or Needs.  Doing so is equivalent   *)
(* to using the Evaluate Initialization Cells menu command in the front *)
(* end.                                                                 *)
(*                                                                      *)
(* DO NOT EDIT THIS FILE.  This entire file is regenerated              *)
(* automatically each time the parent Notebook file is saved in the     *)
(* Mathematica front end.  Any changes you make to this file will be    *)
(* overwritten.                                                         *)
(************************************************************************)



(* ::Input::Initialization:: *)
BeginPackage["LatticePlane`","NDSolve`FEM`","OpenCascadeLink`"(*,"CifImport`"*),"MaXrd`"];
Unprotect@@Names[Evaluate[Context[]<>"*"]];
Unprotect[Evaluate[Context[]<>"*"]];
ClearAll@@Names[Evaluate[Context[]<>"*"]];
ClearAll[Evaluate[Context[]<>"Private`*"]];


(* ::Input::Initialization:: *)
ParseHKL::usage="ParseHKL[hklIn]";
Reciprocal::usage="Reciprocal[hklIn";
AssignAxis::usage="AssignAxis[n,valIn,\[Gamma]]";
AssignAxes::usage="AssignAxes[\[ScriptCapitalI],\[Gamma]]";
GetPositions::usage="GetPositions[\[ScriptCapitalI]]";
OneDimension::usage="OneDimension[\[ScriptCapitalI],\[Gamma]]";
TwoDimension::usage="TwoDimension[\[ScriptCapitalI],\[Gamma]]";
MillerToPlane::usage="MillerToPlane[hkl,\[Gamma]]";
UnitCell::usage="UnitCell[xyz]";
InterplanarAngle::usage="InterplanarAngle[hkl1,hkl2,lattice]";
DegenerateMesh::usage="DegenerateMesh[v]";
TotalIntersectionArea::usage="TotalIntersectionArea[\[ScriptCapitalT],\[ScriptCapitalB]]";
PlaneIntersection::usage="PlaneIntersection[\[ScriptCapitalP],\[ScriptCapitalU]]";
RationalUnitCell::usage="RationalUnitCell[p]";
QUC::usage="QUC[x]";
AtomPolygonBallsIntersection::usage="AtomPolygonBallsIntersection[P,c,r]";
PolygonBallsIntersection::usage="PolygonBallsIntersection[P,c,r]";
AtomProbabilityIntersection::usage="AtomProbabilityIntersection[\[ScriptCapitalD],P]";
ProbabilityIntersection::usage="ProbabilityIntersection[\[ScriptCapitalD],\[ScriptCapitalR],\[ScriptCapitalP]]";
SetupDensityHKL::usage="SetupDensityHKL[mpid,n,hklMax,radiusFactor]";
GetFullHKL::usage="GetFullHKL[valsIn,hklIn,pg]";
DensityHKL::usage=
"{\!\(\*SubscriptBox[\(\[ScriptCapitalA]\), \(int, n\)]\),\!\(\*SubscriptBox[\(hkl\), \(list\)]\),\!\(\*SubscriptBox[\(\[ScriptCapitalE]\), \(unique\)]\)}=DensityHKL[mpid,n,hklMax,radiusFactorIn];
{\!\(\*SubscriptBox[\(\[ScriptCapitalA]\), \(int, n\)]\),\!\(\*SubscriptBox[\(hkl\), \(list\)]\),\!\(\*SubscriptBox[\(\[ScriptCapitalE]\), \(unique\)]\)}=DensityHKL[mpid,n,hklMax,radiusFactorIn,\"Method\"\[Rule]\"PDF\"];"
PlotSetup::usage="{\!\(\*SubscriptBox[\(hkl\), \(list\)]\),reflectionList,pg}=PlotSetup[mpid,n,hklMax];"
PlotSymmetrizedHKL::usage="g=PlotSymmetrizedHKL[vals,hkl,o,legendLabel];"
PlotFullHKL::usage="g=PlotFullHKL[valsIn,hklIn,pg,o,legendLabel];"
PlotSymmetrizedFullHKL::usage="g=PlotSymmetrizedFullHKL[\!\(\*SubscriptBox[\(\[ScriptCapitalA]\), \(out, n\)]\),\!\(\*SubscriptBox[\(hkl\), \(list\)]\),pg,\!\(\*SubscriptBox[\(\[ScriptCapitalE]\), \(unique\)]\),tag];"


(* ::Input::Initialization:: *)
Begin["`Private`"];


(* ::Input::Initialization:: *)
ParseHKL[hklIn_]:=Module[{hkl},
hkl=hklIn/.{OverBar->Minus,0->Indeterminate};
If[Length@hkl==4,hkl=hkl[[{1,2,4}]],hkl]
]


(* ::Input::Initialization:: *)
Reciprocal[hklIn_]:=1/ParseHKL@hklIn


(* ::Input::Initialization:: *)
AssignAxis[n_,valIn_,\[Gamma]_,OptionsPattern[{"BasisVectors"->Null}]]:=Module[{val,B},
val=If[Length@valIn==0,valIn,valIn[[n]]];
B=OptionValue["BasisVectors"];
(*tri=SASTriangle[a,\[Gamma],b]\[LeftDoubleBracket]1\[RightDoubleBracket];*)
out=If[B===Null,
Switch[n,1,{val,0,0},2,{val,val,0}*{Cos[(*90\[Degree]-*)\[Gamma]],Sin[(*90\[Degree]-*)\[Gamma]],0},3,{0,0,val}],
B[[n]]val
];
Rationalize[out,0]
]


(* ::Input::Initialization:: *)
AssignAxes[\[ScriptCapitalI]_,\[Gamma]_,OptionsPattern[{"BasisVectors"->Null}]]:=Module[{},
MapThread[AssignAxis[#1,#2,\[Gamma],"BasisVectors"->OptionValue["BasisVectors"]]&,{{1,2,3},\[ScriptCapitalI]}]
]


(* ::Input::Initialization:: *)
GetPositions[\[ScriptCapitalI]_]:=Flatten@Position[NumberQ/@\[ScriptCapitalI],#]&/@{True(*p*),False(*f*)}


(* ::Input::Initialization:: *)
Options[OneDimension]={"BasisVectors"->Null};
OneDimension[\[ScriptCapitalI]_,\[Gamma]_,OptionsPattern[]]:=Module[{p,f,p1,f1,f2,f3,\[ScriptCapitalO],\[ScriptCapitalA],\[ScriptCapitalB],B},
B=OptionValue["BasisVectors"];
opts="BasisVectors"->B;
{p,f}=GetPositions@\[ScriptCapitalI];
p1=p[[1]];
{f1,f2}=f;
f3=Complement[Range[3],f];
If[B===Null,
\[ScriptCapitalO]=AssignAxis[p1,\[ScriptCapitalI],\[Gamma]],
\[ScriptCapitalO]=(B[[f3]]\[ScriptCapitalI][[f3]])[[1]]
];
\[ScriptCapitalA]=AssignAxis[f1,1,\[Gamma],opts];
\[ScriptCapitalB]=AssignAxis[f2,1,\[Gamma],opts];
InfinitePlane[\[ScriptCapitalO],{\[ScriptCapitalA],\[ScriptCapitalB]}]
]


(* ::Input::Initialization:: *)
TwoDimension[\[ScriptCapitalI]_,\[Gamma]_,OptionsPattern[{"BasisVectors"->Null}]]:=Module[{p,f,p1,p2,f1,f2,f3,B,negQ,\[ScriptCapitalO],\[ScriptCapitalA],\[ScriptCapitalB]},
{p,f}=GetPositions@\[ScriptCapitalI];
{p1,p2}=p[[ ;;2]];
f1=f[[1]];
{f2,f3}=Complement[Range@3,f];
B=OptionValue["BasisVectors"];

If[B===Null,

\[ScriptCapitalO]=AssignAxis[p1,\[ScriptCapitalI],\[Gamma]];
\[ScriptCapitalA]=AssignAxis[p2,\[ScriptCapitalI],\[Gamma]],

\[ScriptCapitalO]=B[[f2]]\[ScriptCapitalI][[f2]];
\[ScriptCapitalA]=B[[f3]]\[ScriptCapitalI][[f3]]
];
\[ScriptCapitalB]=AssignAxis[f1,1,\[Gamma],"BasisVectors"->B];
If[B===Null,
InfinitePlane[{0,0,0},{\[ScriptCapitalA]-\[ScriptCapitalO],\[ScriptCapitalB]}],
InfinitePlane[\[ScriptCapitalA],{\[ScriptCapitalA]-\[ScriptCapitalO],\[ScriptCapitalB]}]
]
]


(* ::Input::Initialization:: *)
Options[MillerToPlane]={"BasisVectors"->Null,"\[Gamma]"->Null};
MillerToPlane[hkl_,\[Gamma]_:Null,OptionsPattern[]]:=Module[{\[ScriptCapitalI],p1,p,f,B,\[Gamma]1},
If[\[Gamma]===Null,\[Gamma]1=OptionValue["\[Gamma]"],\[Gamma]1=\[Gamma]];
\[ScriptCapitalI]=Reciprocal[hkl];
B=OptionValue["BasisVectors"];
If[B=!=Null,
B=Rationalize[B,0];
negQ=Negative[\[ScriptCapitalI]/.Indeterminate->0];
B=MapThread[If[#1,-#2,#2]&,{negQ,B}];
];
{p,f}=GetPositions@\[ScriptCapitalI];
Switch[Length@p(*number of real-valued dimensions*),1,OneDimension[\[ScriptCapitalI],\[Gamma]1,"BasisVectors"->B],2,TwoDimension[\[ScriptCapitalI],\[Gamma]1,"BasisVectors"->B],3,InfinitePlane@AssignAxes[\[ScriptCapitalI],\[Gamma]1,"BasisVectors"->B]]
]


(* ::Input::Initialization:: *)
ReadXYZ[xyzpath_]:=Import[xyzpath,"Table"][[3;;,2;;4]];


(* ::Input::Initialization:: *)
UnitCell[xyz_]:=Module[{\[ScriptCapitalM],\[ScriptP],\[ScriptCapitalC],P,i,\[ScriptCapitalN],\[ScriptCapitalO]},
\[ScriptCapitalM]=Region`Mesh`MergeCells@ConvexHullMesh@Rationalize[xyz,0];
\[ScriptP]=MeshCoordinates@\[ScriptCapitalM];
(*\[ScriptP]=\[ScriptP](1+$MachineEpsilon);*)
\[ScriptCapitalC]=MeshCells[\[ScriptCapitalM],1][[;;,1]];
(*\[ScriptM]={\[ScriptCapitalC]\[LeftDoubleBracket]#\[RightDoubleBracket],\[ScriptP]\[LeftDoubleBracket]#\[RightDoubleBracket]}&/@Range@Length@\[ScriptP];
\[ScriptCapitalN]=Select[\[ScriptM],ContainsAny[#\[LeftDoubleBracket]1\[RightDoubleBracket],{1}]&]\[LeftDoubleBracket];;,2\[RightDoubleBracket];*)
P=Position[\[ScriptCapitalC],_?(ContainsAny[#,{1}]&),1]//Flatten;
i=DeleteCases[Flatten[\[ScriptCapitalC][[P]]],1];
\[ScriptCapitalN]=\[ScriptP][[i]];
\[ScriptCapitalO]=\[ScriptP][[1]];(*\[ScriptCapitalN]=Nearest[\[ScriptP]\[LeftDoubleBracket]2;;\[RightDoubleBracket],\[ScriptCapitalO],3];*)
Parallelepiped[\[ScriptCapitalO],\[ScriptCapitalN]]
]


(* ::Input::Initialization:: *)
RationalUnitCell[R_,n_]:=Module[{R1,R2,R3,c,\[ScriptCapitalU]pts,\[ScriptCapitalU]},
{R1,R2,R3}=R(1+100$MachineEpsilon);(*for some reason Kernel aborts unexpectedly without the machine precision factor*)
c=Floor[n/2](R1+R2+R3);(*corner*)
\[ScriptCapitalU]pts=#-c&/@(n{{0,0,0},R1,R2,R3,R1+R2,R2+R3,R1+R3,R1+R2+R3});
\[ScriptCapitalU]=ConvexHullMesh@\[ScriptCapitalU]pts;
Polyhedron[Rationalize[MeshCoordinates@\[ScriptCapitalU],0],MeshCells[\[ScriptCapitalU],2][[;;,1]]] 
]


(* ::Input::Initialization:: *)
InterplanarAngle[hkl1_,hkl2_,lattice_:"cubic"]:=Module[{h1,k1,l1,h2,k2,l2},
{h1,k1,l1}=ParseHKL@hkl1/. Indeterminate\[RightArrow]0;
{h2,k2,l2}=ParseHKL@hkl2/. Indeterminate\[RightArrow]0;Switch[lattice,"cubic",ArcCos[ (h1 h2+k1 k2+l1 l2)/Sqrt[(h1^2+k1^2+l1^2)(h2^2+k2^2+l2^2)]],"hexagonal",Null,"tetragonal",Null,"trigonal",Null,"monoclinic",Null,"triclinic",Null,"orthorhombic",Null]]


(* ::Input::Initialization:: *)
DegenerateMesh[v_]:=Module[{\[ScriptCapitalR],\[ScriptCapitalN]},\[ScriptCapitalR]=DelaunayMesh@DimensionReduce@v;
\[ScriptCapitalN]=Range@Length@v;
\[ScriptCapitalT]=Last@MeshCells@\[ScriptCapitalR]/. Polygon\[RightArrow]Simplex/. MapThread[#1\[RightArrow]#2&,{\[ScriptCapitalN],v}]]


(* ::Input::Initialization:: *)
TotalIntersectionArea[\[ScriptCapitalT]_,\[ScriptCapitalB]_]:=Table[Area@RegionIntersection[t,b],{t,\[ScriptCapitalT]},{b,\[ScriptCapitalB]}]/. Undefined\[RightArrow]Sequence@@{}//Flatten//Total


(* ::Input::Initialization:: *)
PlaneIntersection[\[ScriptCapitalP]_,\[ScriptCapitalU]_]:=Module[{\[ScriptCapitalP]1,\[ScriptCapitalB],\[ScriptCapitalM],\[ScriptCapitalP]crop,\[ScriptCapitalP]int,shapes,bmesh,d,order,coords,TF},
If[Head@\[ScriptCapitalP]===InfinitePlane,\[ScriptCapitalP]1={\[ScriptCapitalP]},\[ScriptCapitalP]1=\[ScriptCapitalP]];
\[ScriptCapitalB]=RegionResize[BoundingRegion[\[ScriptCapitalU]],Scaled@Rationalize[1.1(*100$MachineEpsilon*)]];(*for cropping the plane*)
\[ScriptCapitalP]crop=RegionIntersection[#,\[ScriptCapitalB]]&/@\[ScriptCapitalP]1;
\[ScriptCapitalP]int=RegionIntersection[#,\[ScriptCapitalU]]&/@(*\[ScriptCapitalP]1*)\[ScriptCapitalP]crop;
shapes=OpenCascadeShape[#]&/@\[ScriptCapitalP]int;
bmesh=OpenCascadeShapeSurfaceMeshToBoundaryMesh[#]&/@shapes;
coords=#["Coordinates"]&/@bmesh;
TF=CoplanarPoints/@coords;
coords=MapThread[If[#1,#2,DimensionReduction[#2,2][#2,"ReconstructedData"]]&,{TF,coords}];
{d,order}=(FindShortestTour[#]&/@coords)\[Transpose];
\[ScriptCapitalP]int=MapThread[Polygon[#1[[#2[[;;-2]]]]]&,{coords,order}]
]


(* ::Input::Initialization:: *)
QUC[x_]:=QuantityMagnitude@UnitConvert@x


(* ::Input::Initialization:: *)
IsotropicMultinormal[pts_,r_]:=MapThread[MultinormalDistribution[#1,DiagonalMatrix@ConstantArray[#2,3]]&,{pts,r}]


(* ::Input::Initialization:: *)
SetupDensityHKL::odd="supercell expansion (n) should be odd";
SetupDensityHKL[mpid_,n_:3,hklMax_:4,radiusFactor_:1/3]:=Module[{pg,\[ScriptCapitalE],\[ScriptF]tmp,R,R1,R2,R3,\[ScriptCapitalO],\[ScriptCapitalE]Unique,\[ScriptF],rKey,r,\[ScriptCapitalE]Pos,\[ScriptCapitalU],\[ScriptCapitalU]pts,reflectionList,hklList,\[ScriptCapitalP],\[ScriptCapitalR],rList,\[ScriptF]List,\[ScriptCapitalD],npts,\[ScriptCapitalA]Sym},

ImportCrystalData[mpid<>".cif"(*Al_mp-134_conventional_standard.cif*)(*"al.cif"*),mpid,"OverwriteWarning"->False];
ExpandCrystal[mpid,{n,n,n},"NewLabel"->mpid<>"_2","StoreTemporarily"->False];(*Defaults to 1x1x1*)

{\[ScriptCapitalE],\[ScriptF]tmp}=(Values/@$CrystalData[[mpid<>"_2","AtomData",;;,{"Element","FractionalCoordinates"}]])\[Transpose];
pg=$CrystalData[[mpid,"SpaceGroup"]];
R=GetCrystalMetric[mpid,ToCartesian->True];
\[ScriptF]=\[ScriptF]tmp . R;
If[!OddQ@n,Message[SetupDensityHKL::odd]];
{R1,R2,R3}=R;
\[ScriptCapitalO]=Floor[n/2](R1+R2+R3);
\[ScriptF]=#-\[ScriptCapitalO]&/@\[ScriptF];
\[ScriptCapitalE]Unique=DeleteDuplicates@\[ScriptCapitalE];
rKey=QUC@ElementData[#,"CovalentRadius"]&/@\[ScriptCapitalE]Unique;
r=radiusFactor*ReplaceAll[\[ScriptCapitalE],Thread[\[ScriptCapitalE]Unique->rKey]]*1*^10(*conversion to Angstroms*);
\[ScriptCapitalE]Pos=PositionIndex@\[ScriptCapitalE];
\[ScriptCapitalU]=RationalUnitCell[R,n];

reflectionList=ReflectionList@hklMax;
hklList=MergeSymmetryEquivalentReflections[pg,reflectionList];
\[ScriptCapitalP]=MillerToPlane[#,\[Gamma]=0,"BasisVectors"->R]&/@hklList;
\[ScriptCapitalR]=PlaneIntersection[\[ScriptCapitalP],\[ScriptCapitalU]];
\[ScriptF]List=\[ScriptF][[#/.\[ScriptCapitalE]Pos]]&/@\[ScriptCapitalE]Unique;
rList=r[[#/.\[ScriptCapitalE]Pos]]&/@\[ScriptCapitalE]Unique;

\[ScriptCapitalD]=MapThread[Rationalize@IsotropicMultinormal[#1,#2]&,{\[ScriptF]List,rList}];
npts=Length@Subscript[hkl, list2];
\[ScriptCapitalA]Sym=Area/@\[ScriptCapitalR]; (*/@\[ScriptCapitalR]*)
{\[ScriptCapitalD],\[ScriptCapitalR],\[ScriptCapitalP],\[ScriptCapitalA]Sym,\[ScriptF]List,rList,hklList,\[ScriptCapitalE]Unique,pg}
]


(* ::Input::Initialization:: *)
DistanceRadiusComparison[i_,j_,n_:3.99]:=Thread[#<n j]&/@i


(* ::Input::Initialization:: *)
TruePosition[x_]:=Flatten@Position[#,_?TrueQ]&/@x


(* ::Input::Initialization:: *)
AtomPolygonBallsIntersection[P_,c_,r_]:=Area/@MeshRegion/@DeleteCases[OpenCascadeShapeSurfaceMeshToBoundaryMesh/@OpenCascadeShape/@DeleteCases[(RegionIntersection[P,#]&/@MapThread[Ball[#1,#2]&,{c,r}]),_EmptyRegion],$Failed]


(* ::Input::Initialization:: *)
AtomPolygonBallsMap[P_,c_,r_]:=MapThread[If[#2!={},Flatten@AtomPolygonBallsIntersection[#1,#2,#3],0]&,{P,c,r}];


(* ::Input::Initialization:: *)
PolygonBallsIntersection[P_,c_,r_,n_:3.99]:=Module[{d,TF,ids,c2,r2,\[ScriptCapitalI]b,\[ScriptCapitalA]b},
d=Table[RegionDistance[i,j],{i,P},{j,#}]&/@c;
TF=MapThread[DistanceRadiusComparison[#1,#2,n]&,{d,r}];
ids=TruePosition[#]&/@TF;
c2=MapThread[#1/.Thread[Range@Length@#2->#2]&,{ids,c}];
r2=MapThread[#1/.Thread[Range@Length@#2->#2]&,{ids,r}];
(*{c2,r2}={c,r};*)
(*{c2,r2,P}*)
(*\[ScriptCapitalI]b=MapThread[Table[AtomPolygonBallsIntersection[i,#1,#2],{i,P}]&,{c2,r2}];*)
\[ScriptCapitalI]b=MapThread[AtomPolygonBallsMap[P,#1,#2]&,{c2,r2}];
(*\[ScriptCapitalI]b=Table[MapThread[If[#1\[LeftDoubleBracket]1\[RightDoubleBracket]\[NotEqual]{},Flatten@AtomPolygonBallsIntersection[{#2},#1\[LeftDoubleBracket]1\[RightDoubleBracket],#1\[LeftDoubleBracket]2\[RightDoubleBracket]],0]&,{i,P}],{i,{c2,r2}\[Transpose]}]*)
\[ScriptCapitalA]b=Total[#,{2}]&/@\[ScriptCapitalI]b
]


(* ::Input::Initialization:: *)
AtomProbabilityIntersection[\[ScriptCapitalD]_,P_]:=(*Parallel*)Table[Quiet[NIntegrate[PDF[i,{x,y,z}]/.PDF[0,{x,y,z}]->0(*for region distance filtering*),{x,y,z}\[Element]j,AccuracyGoal->10],{General::munfl,NIntegrate::slwcon,NIntegrate::precw}],{i,\[ScriptCapitalD]},{j,P}]


(* ::Input::Initialization:: *)
ProbabilityIntersection[\[ScriptCapitalD]_,\[ScriptCapitalR]_,\[ScriptCapitalP]_,n_:3.99,radiusFactor_:1/4]:=Module[{\[ScriptF]List,rList,distances,d,id,\[ScriptCapitalD]2,\[ScriptCapitalI]int,\[ScriptCapitalA]int},
\[ScriptF]List=\[ScriptCapitalD][[;;,;;,1]];
rList=\[ScriptCapitalD][[;;,;;,2,1,1]][[;;,1]];(*assumes isotropic radius and assumes constant radius for a particular element*)
d=Table[RegionDistance[i,j],{i,\[ScriptCapitalP]},{j,#}]&/@\[ScriptF]List;
TF=MapThread[DistanceRadiusComparison[#1,#2,n]&,{d,rList}];
ids=TruePosition[#]&/@TF;
\[ScriptCapitalD]2=MapThread[#1/.Thread[Range@Length@#2->#2]&,{ids,\[ScriptCapitalD]}]/.{}->0;
\[ScriptCapitalI]int=Table[MapThread[Flatten@AtomProbabilityIntersection[#1,{#2}]&,{i,\[ScriptCapitalR]}],{i,\[ScriptCapitalD]2}];
\[ScriptCapitalA]int=Total[#,{2}]&/@\[ScriptCapitalI]int;
\[ScriptCapitalA]int=\[ScriptCapitalA]int \[Pi] (1/radiusFactor rList)^2(*weight the probabilities by the area of the atoms*)
]


(* ::Input::Initialization:: *)
GetFullHKL[valsIn_,hklIn_,pg_]:=Module[{max,\[ScriptR],pi,reflectionList,hklList,valsReplace,n,npts,vals2,hklListSub,valsSub},
max=Max@hklIn;
\[ScriptR]=ReflectionList@max;
pi=PositionIndex[ToStandardSetting[pg,#]&/@\[ScriptR]];(*degenerate sets*)
hklList=MergeSymmetryEquivalentReflections[pg,\[ScriptR]];
valsReplace=Thread[Keys@PositionIndex[hklList]->valsIn]/.pi;
n=Length/@Keys@valsReplace;
npts=Length@\[ScriptR];
vals2=Range@npts/.(Thread[Keys@#->Values@#]&/@valsReplace//Flatten);
{\[ScriptR],vals2}
]


(* ::Input::Initialization:: *)
DensityHKL::mpidNotString="A string was expected for mpid.";
DensityHKL[mpid_:"mp-134",n_Integer:3,hklMax_Integer:4,dFactor:(_Real|_Integer):0.01,radiusFactorIn:(_Real|_Integer):0,OptionsPattern[{"Method"->"PDF","Output"->"PackingFraction","PrintID"->False}]]:=Module[{method,radiusFactor,\[ScriptCapitalD],\[ScriptCapitalR],\[ScriptCapitalP],\[ScriptCapitalA]Sym,\[ScriptF]List,rList,hklList,\[ScriptCapitalE]Unique,\[ScriptCapitalA]out,\[ScriptCapitalA]outn,\[ScriptCapitalA]outCt,pg,hklFull,outCt,outn,\[ScriptCapitalA]fulln,\[ScriptCapitalA]fullCt},
(*If[Head@mpid=!=String,Message[DensityHKL::mpidNotString];Abort[]];*)
If[OptionValue["PrintID"],Print@mpid];
method=OptionValue["Method"];
Print[method];
If[radiusFactorIn==0,Switch[method,"PDF",radiusFactor=1/4,"HardSphere",radiusFactor=1],radiusFactor=radiusFactorIn];
{\[ScriptCapitalD],\[ScriptCapitalR],\[ScriptCapitalP],\[ScriptCapitalA]Sym,\[ScriptF]List,rList,hklList,\[ScriptCapitalE]Unique,pg}=SetupDensityHKL[mpid,n,hklMax,radiusFactor];
Switch[method,
"PDF",\[ScriptCapitalA]out=ProbabilityIntersection[\[ScriptCapitalD],\[ScriptCapitalR],\[ScriptCapitalP],dFactor],
"HardSphere",\[ScriptCapitalA]out=PolygonBallsIntersection[\[ScriptCapitalR],\[ScriptF]List,rList,dFactor]
];
\[ScriptCapitalA]outn=#/\[ScriptCapitalA]Sym&/@\[ScriptCapitalA]out;(*normalize by lattice plane area*)
\[ScriptCapitalA]outCt=MapThread[#1/(\[Pi] #2^2)&,{\[ScriptCapitalA]outn,rList[[;;,1]]}];
outn=GetFullHKL[#,hklList,pg]&/@\[ScriptCapitalA]outn;
hklFull=outn[[1,1]];(*extract a single hklListSub*)
\[ScriptCapitalA]fulln=outn[[;;,2]];(*extract just valsSub*)
outCt=GetFullHKL[#,hklList,pg]&/@\[ScriptCapitalA]outCt;
\[ScriptCapitalA]fullCt=outCt[[;;,2]];(*extract just valsSub*)
{\[ScriptCapitalA]outn,\[ScriptCapitalA]outCt,hklList,\[ScriptCapitalA]fulln,\[ScriptCapitalA]fullCt,hklFull,\[ScriptCapitalE]Unique}
]


(* ::Input::Initialization:: *)
PlotSetup[mpid_,n_:3,hklMax_:4]:=Module[{pg,reflectionList,hklList},
pg=$CrystalData[[mpid,"SpaceGroup"]];
reflectionList=ReflectionList@hklMax;
hklList=MergeSymmetryEquivalentReflections[pg,reflectionList];
{hklList,reflectionList,pg}
]


(* ::Code::Initialization::Bold:: *)
PlotSymmetrizedHKL[vals_,hkl_,o_Integer:1,legendLabel_:"\!\(\*FractionBox[SubscriptBox[\(\[ScriptCapitalA]\), \(\[Integral]\)], SubscriptBox[\(\[ScriptCapitalA]\), \(hkl\)]]\)(\!\(\*SuperscriptBox[\(\[CapitalARing]\), \(-2\)]\))"]:=Module[{max,c,g1},
max=Max@hkl;
c=ColorData[{"AvocadoColors",{0,Max@vals}}];
g1=Graphics3D[{Opacity[o],PointSize[0.05],Point[hkl,VertexColors->c/@vals]},Axes->True,BoxRatios->Automatic,AxesLabel->{"h","k","l"},PlotRange->ConstantArray[{0,max},3],ImageSize->Medium];
Show[Legended[g1,BarLegend[{c,c[[3]]},LegendLabel->legendLabel]],Graphics3D@{FaceForm[None],ConvexHullMesh@hkl}]
]


(* ::Code::Initialization::Bold:: *)
PlotFullHKL[valsIn_,hklIn_,pg_,o_Integer:0.75,legendLabel_:"\!\(\*FractionBox[SubscriptBox[\(\[ScriptCapitalA]\), \(\[Integral]\)], SubscriptBox[\(\[ScriptCapitalA]\), \(hkl\)]]\)(\!\(\*SuperscriptBox[\(\[CapitalARing]\), \(-2\)]\))"]:=Module[{c,hklFull,vals2,\[ScriptR],hklListSub,valsSub,g1},
c=ColorData[{"AvocadoColors",{0,Max@valsIn}}];
{\[ScriptR],vals2}=GetFullHKL[valsIn,hklIn,pg];
{hklListSub,valsSub}=DeleteCases[{\[ScriptR],vals2}\[Transpose],{{x_,y_,z_},_}/;AllTrue[Thread[{x,y,z}>0],TrueQ]]\[Transpose];(*remove a corner of the cube for visualization*)
g1=Graphics3D[{Opacity[o],PointSize[0.08],Point[hklListSub,VertexColors->c/@valsSub]},Axes->True,BoxRatios->Automatic,AxesLabel->{"h","k","l"},ViewPoint->{max,0.6max,0.6max},AxesEdge->{{1,-1},{1,-1},{1,-1}}, PlotRange->ConstantArray[{-max,max},3],ImageSize->Medium];
Show[Legended[g1,BarLegend[{c,c[[3]]},LegendLabel->legendLabel]],Graphics3D@{EdgeForm[White],FaceForm[None],ConvexHullMesh@Permutations[{0,0,0,max,max,max},{3}](*ConvexHullMesh@Complement[hklList,hklListSub]*)}]
]


(* ::Input::Initialization:: *)
PlotSymmetrizedFullHKL[\[ScriptCapitalA]outNorm:_,hklList:_,pg_,\[ScriptCapitalE]Unique:_,tag_:"\[Integral]"]:=Module[{str,x},
str[x_]:=StringTemplate["\!\(\*FractionBox[SubscriptBox[\(\[ScriptCapitalA]\), \(`tag`, `element`\)], SubscriptBox[\(\[ScriptCapitalA]\), \(hkl\)]]\)(\!\(\*SuperscriptBox[\(\[CapitalARing]\), \(-2\)]\))"][<|"element"->x,"tag"->tag|>];
Grid[MapThread[{PlotSymmetrizedHKL[#1,hklList,str[#2]][[1]],PlotFullHKL[#1,hklList,pg,str[#2]]}&,
{\[ScriptCapitalA]outNorm,\[ScriptCapitalE]Unique}]]
]


(* ::Input::Initialization:: *)
End[];
Protect@@Names[Evaluate[Context[]<>"*"]];
Protect[Evaluate[Context[]<>"*"]];
EndPackage[];



